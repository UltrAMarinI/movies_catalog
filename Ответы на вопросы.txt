Ответы на вопросы:1. Как вы можете описать процесс распространения событий в JavaScript (Event Propagation)? Расскажите о его основных фазах. Какие есть способы применения знаний о фазах распространения событий на практике? Есть 3 фазы распространения события: погружение, фаза цели и всплытие.       Погружение – начинается с объекта окна(window), идет вниз к документу(document), телу(body) и далее по дереву к элементу, который вызвал событие.Эта фаза часто используется для делегирования событий, когда нужно отследить события на самом верхнем уровне и отсечь ненужные события заранее.      Фаза цели – событие на целевом элементе, происходят все обработки, привязанные к этому элементу.      Всплытие – событие двигается в обратную сторону от элемента к родителям и до корневого элемента. Это происходит по умолчанию и в это время срабатывают все обработчики.Эта фаза позволяет родительским элементам реагировать на события дочерних элементов.   Мы можем остановить всплытие события при помощи метода stopPropagation( ); например кнопки поверх картинки: если мы нажимаем на кнопки срабатывают одни события, при клике на картинку- другие.2. Расскажите, что такое Promise в JavaScript, как он работает, какие основные состояния у него бывают? Каким еще способом можно обработать асинхронный код? Какую роль в асинхронности играет событийный цикл (Event Loop)? Promise это специальный объект, который связывает «создающий» и «потребляющий» коды вместе. «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов. Промисы возможно объединять в цепочки. В отличии от Observable, промис может вернуть только одно значение или ошибку, а не работать потоком. Промисы делают код более читабельным объединяя цепочки (.then( ).then( )…), и с ними можно просто обрабатывать ошибки при помощи метода .cath( ).      У промиса есть 3 состояния:Ожидание(pending) – это начально состояние.Выполнено(fulfilled) – успешно завершен.Отклонено(rejected) – завершен с ошибкой.      Альтернатива промисам: async/await-является «синтаксическим сахаром» над промисами, Observable – асинхронный паттерн проектирования реализованный в библиотеке RxJS, call-back функции – является устаревшим методом работы с асинхронным кодом   Event Loop – это механизм для работы с асинхронным кодом. Он поддерживает однопоточную модель выполнения кода, но при этом обеспечивает отзывчивость приложения, то есть он обеспечивает работу асинхронного кода. В основе лежит разделение задач на очереди микро и макро тасок, а также синхронный код. Микро таски - это промисы и обратные вызовы, макро таски – это таймеры, DOM события и асинхронные операции ввода-вывода. Вначале выполняется весь синхронный код, далее берется 1 микро таска и выполняется, дальше идет перепроверка синхронного кода, после берется следующая микро таска из очереди микротасок; после того как микро таски закончились очередь доходит до макро тасок, где берется 1 макро таска, после ее выполнения проверяется синхронный код и очередь микро тасок, если в них ничего нет, то выполняется следующая в очереди макро таска и тд.3. Что такое ООП, и какие его ключевые принципы вы могли бы описать? При объяснении приводите примеры. Максимально подробно расскажите о том, как ООП реализовано в JavaScript. ООП(Объектно-ориентрованное программирование) – это парадигма программирования, позволяющая нам с помощью одного объекта создавать множество объектов.В js можно создать объект:* через { … } – это называется литеральный объект, * либо через класс используя ключевое слово new, * также через функцию конструктор использую ключевое слово this. и new,* или c помощью Object.create( ), где объект унаследует другой объект в качестве прототипа.Принципы ООПИнкапсуляция	Принцип ООП, который означает способность объекта «решать», какую информацию он будет раскрывать для внешнего мира, а какую нет. Реализуется этот принцип через публичные и закрытые свойства и методы.В JS инкапсуляция реализуется через замыкания и приватные поля, а не модификаторы доступа.В JS все свойства объектов и методы по умолчанию являются публичными. «Публичный» означает возможность доступа к свойству/методу объекта извне его телаСтандарт ES6+ добавил возможность работы с приватными полями с помощью геттеров(get) и сеттеров(set).Как пример из реальной жизни можно привести устройство автомобиля: Мы видим только корпус, руль, педали, кнопки От нас спрятан двигатель, топливная система, электроника Мы не можем изменить блок управления, регулирование движения цилиндров НаследованиеЭто возможность создавать классы на основе других классов. С помощью этого принципа можно определять родительский класс (с нужными свойствами и методами), а затем дочерний класс, который будет наследовать от родителя все свойства и методы.      В пример можно привести разные профессии      Например сотрудник имеет такие характеристики как:Имя: ‘Иван’,Зарплата: 50 000,Рабочие часы: 8Но у нас есть сотрудники более узких направлений:Имя: ‘Иван’,Зарплата: 100 000,Рабочие часы: 8,Должность: ‘программист’B первом случае у нас родитель, от которого у нас унаследовался ребенок, который получил что-то свое, будь то поле или метод.ПолиморфизмПолиморфизм означает «множество форм», являясь, по сути, довольно простым принципом, отражающим способность метода возвращать разные значения, согласно определённым условиям.Например, кнопка запуск на разных бытовых приборах будет выполнять разные действия. То есть  при одной и той же «форме», мы имеем различный функционал.Так же существует такая техника как Композиция объектов, которая является альтернативой наследованиюС помощью композиции можно присваивать свойства и методы объектам более гибким способом, в результате которого они получают только то, что нужно, и ничего лишнего.Реализуется этот приём довольно просто с помощью функций, которые получают объект в качестве параметра и присваивают ему нужное свойство/метод. Как в конструкторе лего, мы не создаем каждый кирпичик, а берем готовый компонент и собираем из него изделие. JS не использует классическое наследование на классах, вместо этого -прототипное наследование. У нас создается цепочка прототипов. ES6 ввел синтаксис классов, который является синтаксическим сахаром над прототипным наследованием. Это позволяет создавать классы с конструкторами и методами, делая код более читаемым и структурированным. Super в классах это: Вызов родительского конструктора: Animal.call(this, name), установка цепочки прототипов4. Опишите максимально детально, как браузер обрабатывает URL, начиная с момента его ввода в адресную строку и заканчивая отображением страницы. Какие технологии позволяют ускорить процесс? Какие проблемы (безопасность, междоменное взаимодействие) могут возникать в процессе?Когда вы вводите в браузере адрес, начинается путешествие вашего запроса. Компьютеры не понимают символьные адреса — они общаются на языке IP-адресов.Представьте, что вы знаете имя человека, но не знаете его номер телефона. Вы не можете просто выкрикнуть имя из окна и надеяться на ответ — вам нужен конкретный номер для связи.IP-адрес состоит из двух частей:Сам адрес — как адрес домаПорт — как конкретная дверь в этом доме (стандартные порты: 80 для HTTP, 443 для HTTPS) Поиск IP-адреса: DNS-поискЕсли вы уже посещали этот сайт, браузер проверяет кэш в таком порядке:1. Браузерный кэш — самый быстрый2. Кэш операционной системы3. Кэш роутера4. DNS-сервер интернет-провайдераМногоуровневый DNS-поискЕсли адрес не найден в кэше, начинается полноценный поиск:Ваш компьютер -> Роутер -> DNS провайдера -> Корневые DNS-серверы -> Серверы доменной зоны (.com) -> Авторитативные DNS-серверыКорневые серверы знают только домены первого уровня (.com, .org, .ru), а авторитативные серверы знают конкретные IP-адреса для доменов в своих зонах.      Установление соединенияTCP Handshake — "рукопожатие"Перед отправкой данных происходит трехстороннее рукопожатие:Клиент: "Можно подключиться?" (SYN)Сервер: "Да, вот мой номер" (SYN-ACK)  Клиент: "OK, начинаем" (ACK)HTTPS — безопасное соединениеДля защищенного соединения происходит дополнительный "знакомство":Например, вы хотите передать другу данные банковской карты. Сначала убеждаетесь, что это действительно ваш друг:1. Приветствие — обмен "привет"2. Проверка паспорта — сервер отправляет SSL-сертификат3. Проверка подлинности — браузер проверяет сертификат через центры сертификации4. Обмен ключами — создается общий секретный ключ для шифрованияТеперь весь трафик шифруется и защищен от перехвата.      Формирование и отправка запросаСтруктура HTTP-запросаЗапрос состоит из двух частей:Заголовок — мета-информация (браузер, ОС, куки, метод запроса)Тело — данные (для POST-запросов)Методы запроса: GET (получить), POST (отправить), PUT (обновить) и тд.      Слои протоколовЗапрос проходит через "слоеный пирог" сетевых протоколов:* Прикладной уровень — HTTP/HTTPS* Транспортный уровень — TCP (разбивает на пакеты, нумерует, обеспечивает доставку)* Сетевой уровень — IP (маршрутизация)* Канальный/физический уровень — передача битов   Обработка на сервереВеб-сервер (Nginx/Apache)Сервер на порту 443 принимает запрос и:* Определяет запрашиваемый домен (виртуальные хосты)* Находит соответствующую директорию* Определяет, какое приложение должно обработать запросБэкенд-обработка (PHP пример)Nginx -> PHP-FPM (менеджер процессов) -> PHP-интерпретаторPHP-FPM - как "осьминог" с множеством щупалец-процессов, каждый может выполнять PHP-скрипты.Серверная логика:* Обработка бизнес-логики* Работа с базой данных* Формирование ответа   Ответ и доставкаСтруктура HTTP-ответа* Статус — 200 (OK), 404 (Не найдено), 500 (Ошибка сервера)* Заголовки — тип контента, кэширование, куки* Тело — HTML, CSS, JavaScriptОбратный путьОтвет проходит тот же путь назад через множество сетевых узлов, каждый из которых перенаправляет пакеты по оптимальному маршруту.       Рендеринг в браузере1. Парсинг HTML — строит DOM-дерево2. Обрабатка CSS — строит CSSOM-дерево3. Создание Render Tree — объединяет DOM и CSSOM4. Выполнение Layout — рассчитывает расположение элементов5. Отрисовывка — превращает в пиксели6. Композиция — объединяет слоиТаким образом сайт отображается в браузере.